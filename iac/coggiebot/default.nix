{
  self
  , lib
  , pkgs
  , stdenv
  , naerk-lib
  , recursiveMerge
}:
let
  debug = expr: builtins.trace expr expr;

  coggiebot-setup = features-list:
    {
      name = "coggiebot";
      nativeBuildInputs = [];
      buildInputs = [];

      REV=(self.rev or "canary");
      src = ../../.;

      passthru = {
        inherit features-list;
      };
    };

  # these are
  genericFeature = {name, pkg-override ? (c: c), dependencies ? [], config-options ? {}}:
    {
      ${name} = {
        featureName = "${name}";

        inherit dependencies pkg-override config-options;
      };
    };

  features =
    let
      raw-mockingbird = pkgs.callPackage ./mockingbird.nix { inherit genericFeature naerk-lib ; };
      mockingbird-lib =
        builtins.removeAttrs raw-mockingbird ["override" "overrideDerivation"];
    in
      recursiveMerge (
        (lib.foldl (s: x: s ++ [(genericFeature x)]) []
        [
          { name = "basic-cmds"; }
          { name = "bookmark"; }
          { name = "list-feature-cmd"; }
          {
            name = "prerelease";
            pkg-override = (prev: {
              prev.buildInputs = prev.buildInputs ++ [ pkgs.git ];
            });
          }
          {
            name = "mockingbird";
            pkg-override = mockingbird-lib.mockingbird-fn;
          }
          {
            name = "demix";
            pkg-override = coggiebot: mockingbird-lib.demix-fn coggiebot;
            dependencies = [ "mockingbird" ];
          }
          {
            name = "dj-channel";
            dependencies = [ "demix" ];
          }
          # { name = "fake"; dependencies = [ "nonexist" ]; }
        ])
      );

  all-features-list = lib.mapAttrsToList (_: v: v) features;

  # create a list of all features, add a boolean field (enabled) to signify
  # if coggiebot has that feature enabled
  which-features-list = coggiebot:
    lib.foldl (s: f:
      s
      # if the feature is enabled, add a new field and set it to 1
      ++ [({enabled = lib.lists.any (x: x == f) coggiebot.passthru.features-list;} // f)])
      [] all-features-list;

  # New line separated.
  # The suffix number describes if the feature name was enabled. (1: enabled, 0: disabled)
  # The delimiter ':' is used to separate the feature name from the suffix.
  featurelist = coggiebot: pkgs.writeTextDir
    "share/coggiebot-features.list"
    ''
      # This file is automatically generated by coggiebot.
      ################################################################
      # It contains a list of features that were enabled for this build.
      # The suffix number describes if the feature name was enabled. (1: enabled, 0: disabled)
      # The delimiter ':' is used to separate the feature name from the suffix.
      #
      # This file is read by coggiebot to determine which features are enabled.
      ${
        lib.concatMapStrings (feature:
          "${feature.featureName}:${if feature.enabled then "1" else "0"}\n")
           (which-features-list coggiebot)
      }
    '';
in
rec {
  inherit
    debug
    which-features-list
    all-features-list
    featurelist
    genericFeature
    features
    coggiebot-setup;

  raw-mockingbird = builtins.removeAttrs (pkgs.callPackage ./mockingbird.nix { inherit genericFeature naerk-lib ; }) ["override" "overrideDerivation"];
  ####
  # coggiebotWrapped = pkgs.writeShellScriptBin "coggiebot" ''
  # #!${pkgs.stdenv.shell}
  # export LD_LIBRARY_PATH=${pkgs.libopus}/lib
  # export PATH=${pkgs.ffmpeg}/bin:${pkgs.youtube-dl}/bin:${mockingbird.deemix-extractor}/bin
  # exec ${coggiebot}/bin/coggiebot $@
  # '';
  ####
  dependency-check = coggiebot:
    let
      nodeps-filter =  lib.filter (f: f.dependencies != []);
      enabled-filter = lib.filter (f: f.enabled);

      marked-features-list = (which-features-list coggiebot);
      marked-features = lib.foldl (s: x: (s // { ${x.featureName} = x;}))
        {}
        marked-features-list;

      map-features = map (x:
        map (x: marked-features.${x}) x
      );

      recursive-missing-step = filter-fn: deps:
        let
          missing-deps = lib.filter filter-fn (map-features deps);
        in
          if missing-deps == [] then
            []
          else
            missing-deps ++ (recursive-missing-step (map (x: x.dependencies) missing-deps));

      recursive-missing-deps = filter-fn: deps:
        let
          missing-deps = recursive-missing-step filter-fn deps;
        in
          if missing-deps == [] then
            []
          else
            missing-deps ++ (recursive-missing-deps (map (x: x.dependencies) missing-deps));

      nonexistent-deps =
        let dependents = lib.filter nodeps-filter all-features-list;
        in
          lib.filter (f: !lib.all(dep: (builtins.hasAttr dep features)) f.dependencies) dependents;

      enabled-features-with-missing-dependencies =
          recursive-missing-deps enabled-filter
            (map (f: f.dependencies)
              (lib.filter
              (f: lib.lists.all (dep: marked-features.${dep}.enabled) f.dependencies)
                (enabled-filter (nodeps-filter marked-features-list)))
            );

      # check that `f.dependencies` are initialized prior to `f`
      enabled-features-with-wrong-order =
        (lib.foldl' (s: f:
          let
            deps = f.dependencies;

            contains-all = a: lib.lists.all (x: lib.lists.elem x a);
            all-deps-enabled = contains-all s.ok f.dependencies;
          in
            {
              ok = s.ok ++ (lib.optional all-deps-enabled [f.featureName]);
              err =
                s.err ++
                  (lib.optional (!all-deps-enabled)
                    [
                      (f // {
                        missing=recursive-missing-deps (x: !(lib.lists.elem x s.ok)) f.dependencies;
                      })
                    ]);
            }
        )
          { ok=[]; err=[]; }
          (lib.filter (x: x.enabled) (marked-features-list))
        );
    in
      if (nonexistent-deps != []) then
        throw ''
          The following features do not exist within the final "features" set:
          ${lib.concatMapStrings (f: "  ${f.featureName} ->  ${lib.concatMapStrings (x: "${x}, ") f.dependencies}\n") nonexistent-deps}
        ''
      else if ((debug enabled-features-with-missing-dependencies) != []) then
        throw ''
          The following features are enabled but have missing dependencies:
          ${lib.concatMapStrings (f: "  ${f.featureName}\n") enabled-features-with-missing-dependencies}
          ''
      else if (enabled-features-with-wrong-order.err != []) then

        throw ''
          The following features are enabled but have dependencies that are not enabled in the correct order:

            ${lib.concatMapStrings (f:
              "  ${
                lib.concatMapStrings (f: "${f.featureName}, -> ${
                    lib.concatMapStrings (z: "${z}, ") f.missing
                  }") f
              }\n")
              (enabled-features-with-wrong-order.err)
             }
          ''
      else
        coggiebot;

  # Force build to have no default features enabled
  # MkCoggiebot' { } -> naesrk-lib.buildPackage -> mkDerivation
  mkCoggiebot = {
    features-list ? [],
    options ? {},
  }:
    let
      coggie = (coggiebot-setup features-list);

      pkg =
        lib.foldl (c: f: c // (f.pkg-override c))
          coggie coggie.passthru.features-list;

      drv =
        (naerk-lib.buildPackage ((dependency-check pkg) // {
            cargoBuildOptions=
              l: l
                 ++ ["--no-default-features"]
                 ++ (lib.optional (pkg.passthru.features-list != [])
                   ["--features"] ++ [(lib.concatStringsSep ","
                     (lib.foldl (s: x: s ++ [x.featureName]) [] pkg.passthru.features-list)
                   )]);
          }));
    in
      pkgs.symlinkJoin {
          name = "coggiebot";
          paths = [
            drv
            ( featurelist coggie )

          ];
        };
}
